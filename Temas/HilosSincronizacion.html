<!DOCTYPE HTML>
<!--
	Alpha by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Aplicaciones Distribuidas 7mo D</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<header id="header" >
				<h1><a href="index.html">Aplicaciones Distribuidas 7mo D</h1>
				<nav id="nav">
					<ul>
						<li><a href="index.html">Inicio</a></li>
						<li>
							<a href="#" class="icon solid fa-angle-down">Temas</a>
							<ul>
								<li>
									<a href="#">Parcial Uno</a>
									<ul>
										<li><a href="HilosSincronizacion.html">Hilos y Sincronización</a></li>
										<li><a href="ForkJoin.html">Fork Join</a></li>
										<li><a href="StreamParalelas.html">Streams Paralelas</a></li>
										<li><a href="JavaStreams.html">Java Streams</a></li>
										<li><a href="TcpIp_Sockets.html">TCP/IP Sockets UDP</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Dos</a>
									<ul >
										<li><a href="RPC_RMI.html">RPC y RMI</a></li>
										<li><a href="VirtualizacionContenedores.html">Virtualización y Cont</a></li>
										<li><a href="SpringySpringBoot.html">Spring y SpringBoot</a></li>
										<li><a href="SpringWebMVC.html">Spring Web MVC</a></li>
										<li><a href="SpringBDD.html">Spring BDD</a></li>
										<li><a href="PlantWebSpring.html">Plantillas Web Spring</a></li>
										<li><a href="ServWebJMS.html">Servicios Web JMS</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Tres</a>
									<ul>
										<li><a href="SistDistArchivos.html">Sistemas Dist de Archivos</a></li>
										<li><a href="Hadoop.html">Hadoop</a></li>
										<li><a href="Spark.html">Spark</a></li>
										<li><a href="MPI_ZeroMQ_NNG.html">MPI, ZeroMQ, NNG</a></li>
										
									</ul>
								</li>
							</ul>
						</li>
						<li>
							<a href="#" class="icon solid fa-angle-down">Consultas</a>
							<ul>
								<li>
									<a href="#">Parcial Uno</a>
									<ul>
										<li><a href="../Consultas/MapReduce.html">Map Reduce</a></li>
										<li><a href="../Consultas/ForkJoin.html">Fork Join</a></li>
										<li><a href="../Consultas/MetodosPorDefecto.html">Metodos por Defecto</a></li>
										<li><a href="../Consultas/ExpLambda.html">Expresión Lambda</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Dos</a>
									<ul>
										<li><a href="../Consultas/MaquinaVirtual.html">Maquina Virtual</a></li>
										<li><a href="../Consultas/VirtualBox.html">Virtual Box</a></li>
										<li><a href="../Consultas/Contenedores.html">Contenedores</a></li>
										<li><a href="../Consultas/Docker.html">Docker</a></li>
										<li><a href="../Consultas/InversionControl.html">Inversión de Control</a></li>
										<li><a href="../Consultas/InyeccionDependencias.html">Inyección Dependencia</a></li>
										<li><a href="../Consultas/ConvencionConfig.html">Convencion Config</a></li>
										<li><a href="../Consultas/MVC.html">MVC</a></li>
									</ul>
								</li>
								<li>
									<a href="#">Parcial Tres</a>
									<ul>
										<li><a href="../Consultas/JSP.html">JSP</a></li>
										<li><a href="../Consultas/Thymeleaf.html">Thymeleaf</a></li>
										<li><a href="../Consultas/FreeMarker.html">Freemarker</a></li>
										<li><a href="../Consultas/Groovy.html">Groovy</a></li>																				
									</ul>
								</li>
							</ul>
						</li>
						<!-- <li><a href="#" class="button">Sign Up</a></li> -->
					</ul>
				</nav>
			</header>
			<!-- Main -->
				<section id="main" class="container">
					<header>
						<h2>Hilos y Sincronización</h2>
						<!-- <p>A generic page for every non-generic situation.</p>Main -->
					</header>
					<div class="box">
						<span class="image featured"><img src="images/pic01.jpg" alt="" /></span>
						<h3>Paralelismo e Hilos en Java</h3>
							<p  align="justify">El paralelismo es la ejecución simultánea de dos o más tareas. Se considera una propiedad del hardware, 
								ya que requiere recursos físicos para ejecutar cada tarea simultáneamente, y su objetivo se basa en realizar una tarea en el menor tiempo posible.
							</p>
								<p align="justify"> El paralelismo acelera la ejecución de una tarea dividiéndola en computaciones independientes y ejecutándola sobre hardware capaz de realizar computaciones simultáneas, 
									como por ejemplo un procesador con varios núcleos. Pero cuando ejecutamos una tarea paralelizada en múltiples ordenadores, en vez de en los múltiples cores de un solo ordenador, 
									decimos que la computación paralela es distribuída. Por ejemplo, cada búsqueda en Google se ejecuta simultáneamente en cientos de ordenadores,
									cada uno de los cuales busca al mismo tiempo en un subconjunto del índice del web.
								</p>
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/paralelismo.png"
										width="700"
										height="400">
									</div>

						<div class="row">
							<div class="row-6 row-12-mobilep">
								<h3>¿Qué son los hilos?</h3>
								<p align="justify">Un hilo es un flujo de control dentro de un programa. Creando varios hilos podremos realizar varias tareas simultáneamente. 
									Cada hilo tendrá sólo un contexto de ejecución (contador de programa, pila de ejecución).
								</p>
							</div>
							<div class="row-6 row-12-mobilep">
								<h3>Creacion de Hilos</h3>
								<p align="justify">En Java los hilos están encapsulados en la clase Thread. Para crear un hilo tenemos dos posibilidades:
									Heredar de Thread redefiniendo el método run().
									Crear una clase que implemente la interfaz Runnable que nos obliga a definir el método run().
													
									En ambos casos debemos definir un método run() que será el que contenga el código del hilo. Desde dentro de este método podremos llamar a cualquier otro método de cualquier objeto, 
									pero este método run() será el método que se invoque cuando iniciemos la ejecución de un hilo. El hilo terminará su ejecución cuando termine de ejecutarse este método run(). 
									Para crear nuestro hilo mediante herencia haremos lo siguiente: 
								</p>
								<div align="center"><img src="../IMAGENES_GRUPO/GRUPO1/hilos.png"
									width="700"
									height="400">
								</div>
							</div>
						</div>
						
						<div class="row">
							<div class="row-6 row-12-mobilep">
								<h3>Candado de uso exclusivo</h3>
								<p align="justify">Cuando se utiliza la palabra clave synchronized se esta indicando una zona restringida para el uso de Threads, 
									esta zona restringida para efectos prácticos puede ser considerada un candado (“lock”) sobre la instancia del objeto en cuestión.
								</p>
							</div>
							<div class="row-6 row-12-mobilep">
								<h3>Candado</h3>
								<p align="justify">Todos los objetos (incluidos los arrays) tienen un “candado” (lock). 
									Solo un hilo puede tener bloqueado el candado de un objeto en un momento dado. 
									Podrá bloquearlo más de una vez antes de liberarlo y solo quedará completamente libre cuando el hilo lo libere tantas veces como lo ha obtenido.  
									Si  un hilo intenta obtener un candado ocupado, quedará suspendida hasta que éste se libere y pueda obtenerlo. No se puede acceder directamente a los candados..
								</p>

								<h3>Ejemplo de sincronizacion candado de uso exclusivo</h3>

								<iframe width="600" height="300" src="https://www.youtube.com/embed/sHwFkximn2E" frameborder="0"
									allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
							</div>
						</div>

						<div class="row">
							<div class="row-6 row-12-mobilep">
								<h3>Sincronizacion Java CandadoRW</h3>
								<p align="justify">La mayoría de los elementos de java.util.concurrent no utilizan synchronized. Entonces, 
									¿cómo logran ser seguros a hilos? Pues utilizan la nueva interfaz Lock, que tiene semántica similar a synchronized; 
									pero ofrece alto desempeño y características adicionales, tales como la habilidad de interrumpir un hilo que está esperando por un bloqueo, 
									esperar un bloqueo por un tiempo específico, preguntar por la disponibilidad de un bloqueo, etc.
								</p>
							</div>
							<div class="row-6 row-12-mobilep">
								<h3>Ejemplo de sincronizacion candado RW</h3>
								<iframe width="600" height="300" src="https://www.youtube.com/embed/hcfUP8cc03M" frameborder="0" allow="accelerometer; autoplay;
									clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
								</iframe>

							</div>
						</div>

						<div class="row">
							<div class="row-6 row-12-mobilep">
								
								<h3>Sincronizacion Java Barrera</h3>
								
								<p align="justify">Cuando trabajamos con hilos en Java, nos puede interesar que varios hilos comiencen su ejecución a la vez o nos puede interesar esperar a 
								que terminen todos los hilos que hemos lanzado previamente. Esperar por un solo hilo no es problema, ese hilo tiene el método join() que hace exactamente eso, esperar a que termine </p>
							
								<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 1.png"
											width="500"
											height="300"></div>
									<br>

								<p align="justify">sin embargo, esperar por muchos hilos nos implicaría hacer muchas llamadas join(), una por cada hilo arrancado.
									Para arrancar varios hilos a la vez o para esperar que todos ellos terminen, java nos ofrece la clase CyclicBarrier. 
									Esta clase se instancia pasándole en el constructor cuántos hilos debe sincronizar. Los hilos deben llamar al método await() de CyclicBarrier y se quedarán ahí detenidos. 
									CyclicBarrier los liberará cuando tenga tantos hilos a la espera como se le haya indicado en el constructor.

									Si queremos que varios hilos empiecen a la vez (por ejemplo, 5 hilos), tendremos que hacer lo siguiente
								</p>

									<br>
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 2.png"
										width="500"
										height="300"></div>
									<br>
									
									<p align="justify">y cada hilo debe hacer la siguiente llamada</p>

									<br>
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 3.png"
										width="500"
										height="300"></div>
									<br>

									<p align="justify">Si queremos esperar que los 5 hilos terminen su ejecución, debemos hacer una CyclicBarrier de 6, los 5 hilos más otro para nuestro propio hilo. El código sería</p>

									<br>
										
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 4.png"
										width="500"
										height="300"></div>
									<br>

								<p align="justify">Los 5 hilos deberían hacer </p>
									
									<br>
										
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 5.png"
										width="500"
										height="300"></div>
									<br>
									
									<p align="justify"> y en nuestro código principal, después de lanzar los 5 hilos, haríamos</p>	

									<br>
										
									<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Barrera 6.png"
											width="500"
											height="300"></div>
										<br>
					
									<p align="justify">El unico problema para este mecanismo es que los 5 hilos se quedan bloqueado sin terminar hasta que el hilo principal hace también su llamada a await().</p>
										<br> 
							</div>
							<div class="row-6 row-12-mobilep">
								<h3>Sincronizacion Java Colas</h3>

								<p align="justify">Una Queue que además admite operaciones que esperan a que la cola no esté vacía al recuperar un elemento, y esperan a que haya espacio disponible en la cola cuando se almacena un elemento.</p>
	  							<p align="justify">Los métodos BlockingQueue vienen en cuatro formas, con diferentes formas de manejar operaciones que no pueden satisfacerse inmediatamente, pero pueden satisfacerse en algún momento en el futuro: uno lanza una excepción, 
								el segundo devuelve un valor especial (ya sea nulo o falso , dependiendo de la operación), el tercero bloquea el hilo actual indefinidamente hasta que la operación pueda tener éxito, y el cuarto bloquea solo por un límite de tiempo máximo dado antes de darse por vencido.</p>	
			
								<p align="justify">Un BlockingQueue no acepta elementos nulos . Las implementaciones lanzan NullPointerException en los intentos de agregar , poner u ofrecer un valor nulo . Un nulo se utiliza como valor centinela para indicar el fracaso de las operaciones de sondeo .
									Un BlockingQueue puede tener un límite de capacidad. En cualquier momento puede tener una capacidad restante más allá de la cual no se 
									pueden colocar elementos adicionales sin bloquear. Un BlockingQueue sin restricciones de capacidad intrínseca siempre informa una capacidad restante de Integer.MAX_VALUE .
									Las implementaciones de BlockingQueue están diseñadas para usarse principalmente para colas de productor-consumidor, pero además son compatibles con la Collectioninterfaz. 
									Entonces, por ejemplo, es posible eliminar un elemento arbitrario de una cola usando remove (x) . Sin embargo, estas operaciones en general no se realizan de manera muy eficiente y están pensadas para un uso ocasional, 
									como cuando se cancela un mensaje en cola. 
								</p>
	
								<p align="justify">Las implementaciones de BlockingQueue son seguras para subprocesos. Todos los métodos de cola logran sus efectos de forma atómica utilizando bloqueos internos u otras formas de control de concurrencia. 
									Sin embargo, los graneles operaciones Collection addAll , containsAll , retainAll y removeAll se no necesariamente se llevan a cabo de forma atómica menos que se especifique lo contrario en una implementación. 
								</p>
								<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/S-colas.png"
									width="500"
									height="300"></div>
									<br>
							</div>
						</div>

						<div class="row">
							<div class="row-6 row-12-mobilep">
								<h3>Sincronizacion Java Deadlock</h3>
								<p align="justify">Deadlock sucede cuando dos threads se bloquean en espera del lock de un objeto que cada thread posee. 
									Ni uno de los threads se puede ejecutarse hasta que el otro abandone su lock, por lo que esperarán para siempre o se bloqueara indefinidamente. 
								</p>
							</div>
							<div class="row-6 row-12-mobilep">
								<h3>Interacción de Threads</h3>

								<p align="justify">El interbloqueo puede definirse formalmente como: Un conjunto de procesos está en interbloqueo si cada proceso del conjunto está esperando un evento que sólo otro proceso del conjunto puede causar. 
									Puesto que todos los procesos están esperando, ninguno de ellos puede causar ninguno de los eventos que podrían despertar a cualquiera de los demás miembros del conjunto, y todos los procesos continúan esperando indefinidamente. 
								</p>

								<h3>Ejemplo de Deadlock</h3>

								<div align="center"><img src="../IMAGENES_GRUPO/GRUPO 1/Ejemplo en java.png"
									width="500"
									height="300"></div>

							</div>
						</div>

					</div>
				</section>

			<!-- Footer -->
				<footer id="footer">
						<ul class="copyright">
						<li>&copy; Aplicaciones Distribuidas. All rights reserved.</li>
					</ul>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.dropotron.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>